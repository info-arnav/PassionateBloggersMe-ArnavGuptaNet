{
  "manifest": {
    "name": "babylon-walk",
    "version": "1.0.2",
    "description": "Lightweight Babylon AST traversal",
    "main": "lib/index.js",
    "jsnext:main": "src/index.js",
    "files": [
      "lib",
      "src"
    ],
    "scripts": {
      "prepublish": "babel -d lib src"
    },
    "repository": {
      "type": "git",
      "url": "https://github.com/pugjs/babylon-walk.git"
    },
    "author": {
      "name": "Timothy Gu",
      "email": "timothygu99@gmail.com"
    },
    "license": "MIT",
    "dependencies": {
      "babel-runtime": "^6.11.6",
      "babel-types": "^6.15.0",
      "lodash.clone": "^4.5.0"
    },
    "devDependencies": {
      "babel-cli": "^6.14.0",
      "babel-plugin-transform-runtime": "^6.15.0",
      "babel-preset-es2015": "^6.14.0"
    },
    "_registry": "npm",
    "_loc": "/home/ubuntu/.cache/yarn/v6/npm-babylon-walk-1.0.2-3b15a5ddbb482a78b4ce9c01c8ba181702d9d6ce-integrity/node_modules/babylon-walk/package.json",
    "readmeFilename": "README.md",
    "readme": "# babylon-walk\n\nLightweight AST traversal tools for [Babylon] ASTs.\n\nBabylon is the parser used by the [Babel] project, which supplies the wonderful [babel-traverse] module for walking Babylon ASTs. Problem is, babel-traverse is very heavyweight, as it is designed to supply utilities to make all sorts of AST transformations possible. For simple AST walking without transformation, babel-traverse brings a lot of overhead.\n\nThis module loosely implements the API of Acorn parser's [walk module], which is a lightweight AST walker for the ESTree AST format.\n\nIn my tests, babylon-walk's ancestor walker (the most complex walker provided by this module) is about 8 times faster than babel-traverse, if the visitors are cached and the same AST is used for all runs. It is about 16 times faster if a fresh AST is used every run.\n\n[![Dependency Status](https://img.shields.io/david/pugjs/babylon-walk.svg)](https://david-dm.org/pugjs/babylon-walk)\n[![NPM version](https://img.shields.io/npm/v/babylon-walk.svg)](https://www.npmjs.com/package/babylon-walk)\n\n[Babylon]: https://github.com/babel/babylon\n[Babel]: https://babeljs.io/\n[babel-traverse]: https://github.com/thejameskyle/babel-handbook/blob/master/translations/en/plugin-handbook.md#toc-babel-traverse\n[walk module]: https://github.com/ternjs/acorn#distwalkjs\n\n## Installation\n\n```sh\n$ npm install babylon-walk\n```\n\n## API\n\n```js\nvar walk = require('babylon-walk');\n```\n\n### walk.simple(node, visitors, state)\n\nDo a simple walk over the AST. `node` should be the AST node to walk, and `visitors` an object containing Babel [visitors]. Each visitor function will be called as `(node, state)`, where `node` is the AST node, and `state` is the same `state` passed to `walk.simple`.\n\nWhen `walk.simple` is called with a fresh set of visitors, it will first \"explode\" the visitors (e.g. expanding `Visitor(node, state) {}` to `Visitor() { enter(node, state) {} }`). This exploding process can take some time, so it is recommended to [cache your visitors] and communicate state leveraging the `state` parameter. (One difference between the linked article and babylon-walk is that the state is only accessible through the `state` variable, never as `this`.)\n\nAll [babel-types] aliases (e.g. `Expression`) and the union syntax (e.g. `'Identifier|AssignmentPattern'(node, state) {}`) work.\n\n### walk.ancestor(node, visitors, state)\n\nDo a simple walk over the AST, but memoizing the ancestors of the node and making them available to the visitors. `node` should be the AST node to walk, and `visitors` an object containing Babel [visitors]. Each visitor function will be called as `(node, state, ancestors)`, where `node` is the AST node, `state` is the same `state` passed to `walk.ancestor`, and `ancestors` is an array of ancestors to the node (with the outermost node being `[0]` and the current node being `[ancestors.length - 1]`). If `state` is not specified in the call to `walk.ancestor`, the `state` parameter will be set to `ancestors`.\n\nWhen `walk.ancestor` is called with a fresh set of visitors, it will first \"explode\" the visitors (e.g. expanding `Visitor(node, state) {}` to `Visitor() { enter(node, state) {} }`). This exploding process can take some time, so it is recommended to [cache your visitors] and communicate state leveraging the `state` parameter. (One difference between the linked article and babylon-walk is that the state is only accessible through the `state` variable, never as `this`.)\n\nAll [babel-types] aliases (e.g. `Expression`) and the union syntax (e.g. `'Identifier|AssignmentPattern'(node, state) {}`) work.\n\n### walk.recursive(node, visitors, state)\n\nDo a recursive walk over the AST, where the visitors are responsible for continuing the walk on the child nodes of their target node. `node` should be the AST node to walk, and `visitors` an object containing Babel [visitors]. Each visitor function will be called as `(node, state, c)`, where `node` is the AST node, `state` is the same `state` passed to `walk.recursive`, and `c` is a function that takes a single node as argument and continues walking _that_ node. If no visitor for a node is provided, the default walker algorithm will still be used.\n\nWhen `walk.recursive` is called with a fresh set of visitors, it will first \"explode\" the visitors (e.g. expanding `Visitor(node, state) {}` to `Visitor() { enter(node, state) {} }`). This exploding process can take some time, so it is recommended to [cache your visitors] and communicate state leveraging the `state` parameter. (One difference between the linked article and babylon-walk is that the state is only accessible through the `state` variable, never as `this`.)\n\nUnlike other babylon-walk walkers, `walk.recursive` does not call the `exit` visitor, only the `enter` (the default) visitor, of a specific node type.\n\nAll [babel-types] aliases (e.g. `Expression`) and the union syntax (e.g. `'Identifier|AssignmentPattern'(node, state) {}`) work.\n\nIn the following example, we are trying to count the number of functions in the outermost scope. This means, that we can simply walk all the statements and increment a counter if it is a function declaration or expression, and then stop walking. Note that we do not specify a visitor for the `Program` node, and the default algorithm for walking `Program` nodes is used (which is what we want). Also of note is how I bring the `visitors` object outside of `countFunctions` so that the object can be cached to improve performance.\n\n```js\nimport * as t from 'babel-types';\nimport {parse} from 'babylon';\n\nconst visitors = {\n  Statement(node, state, c) {\n    if (t.isVariableDeclaration(node)) {\n      for (let declarator of node.declarations) {\n        // Continue walking the declarator\n        c(declarator);\n      }\n    } else if (t.isFunctionDeclaration(node)) {\n      state.counter++;\n    }\n  },\n\n  VariableDeclarator(node, state) {\n    if (t.isFunction(node.init)) {\n      state.counter++;\n    }\n  }\n};\n\nfunction countFunctions(node) {\n  const state = {\n    counter: 0\n  };\n  walk.recursive(node, visitors, state);\n  return state.counter;\n}\n\nconst ast = parse(`\n  // Counts\n  var a = () => {};\n\n  // Counts\n  function b() {\n    // Doesn't count\n    function c() {\n    }\n  }\n\n  // Counts\n  const c = function d() {};\n`);\n\ncountFunctions(ast);\n// = 3\n```\n\n[babel-types]: https://github.com/babel/babel/tree/master/packages/babel-types\n[cache your visitors]: https://github.com/thejameskyle/babel-handbook/blob/master/translations/en/plugin-handbook.md#toc-optimizing-nested-visitors\n[visitors]: https://github.com/thejameskyle/babel-handbook/blob/master/translations/en/plugin-handbook.md#toc-visitors\n\n## Caveat\n\nFor those of you migrating from Acorn to Babylon, there are a few things to be aware of.\n\n1. The visitor caching suggestions do not apply to Acorn's walk module, but do for babylon-walk.\n\n2. babylon-walk does not provide any of the other functions Acorn's walk module provides (e.g. `make`, `findNode*`).\n\n3. babylon-walk does not use a `base` variable. The walker algorithm is the same as what babel-traverse uses.\n   - That means certain nodes that are not walked by Acorn, such as the `property` property of a non-computed `MemberExpression`, are walked by babylon-walk.\n\n## License\n\n  MIT\n",
    "licenseText": "Copyright (c) 2016 Tiancheng \"Timothy\" Gu\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/babylon-walk/-/babylon-walk-1.0.2.tgz#3b15a5ddbb482a78b4ce9c01c8ba181702d9d6ce",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/babylon-walk/-/babylon-walk-1.0.2.tgz",
    "hash": "3b15a5ddbb482a78b4ce9c01c8ba181702d9d6ce",
    "integrity": "sha1-OxWl3btIKni0zpwByLoYFwLZ1s4=",
    "registry": "npm",
    "packageName": "babylon-walk",
    "cacheIntegrity": "sha512-/AcxC8CZ6YzmKNfiH3+XLjJDbhED3qxSrd4uFNvJ91pcsPuwMNXxfjwHxhiYOidhpis0BiBu/gupOdv2EYyglg== sha1-OxWl3btIKni0zpwByLoYFwLZ1s4="
  },
  "registry": "npm",
  "hash": "3b15a5ddbb482a78b4ce9c01c8ba181702d9d6ce"
}